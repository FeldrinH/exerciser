import copy
import math
import numbers
import random
from typing import NamedTuple, Protocol
import matplotlib.pyplot as plt
import numpy as np
import exerciser
import pygame # Note: Pygame must be imported after exerciser to avoid the welcome message.

from exerciser import show_value, DELTA, TPS # Re-export

# NB: DO NOT EDIT THIS FILE!

class PID(Protocol):
    def control(self, delta: float, x: float) -> float:
        ...

class ExerciseParams(NamedTuple):
    x: float
    angle: float

def get_exercise_params(exercise: int) -> ExerciseParams:
    """
    Get exercise parameters by exercise number (in the range 1..3).
    Note that the parameters of exercise 3 are random.
    """

    if exercise == 1:
        return ExerciseParams(100, 0)
    elif exercise == 2:
        return ExerciseParams(100, 30)
    elif exercise == 3:
        return ExerciseParams(random.uniform(-200, 200), random.uniform(-60, 60))
    else:
        raise exerciser.ValidationError(f"Unknown exercise number: {exercise}")

_GRAVITY = 50 # Effective gravitational acceleration: 50 px/s^2

# # Thread-local variable for storing reference to dictionary where user-shown values are stored.
# _collection_target: ContextVar[Optional[Dict]] = ContextVar('collected_values', default=None)

class PIDSimulation(exerciser.Simulation):
    name = "Lab 1 - PID"

    # TODO: Currently distance units are pixels. Should we use more natural distance units such as meters with some kind of scaling constant?
    t = 0.0
    x: float
    vx = 0.0
    F = math.nan

    def __init__(self, pid: PID, params: ExerciseParams):
        if not isinstance(params, ExerciseParams):
            raise exerciser.ValidationError(f"Expected exercise parameters, got {params}. (Call get_exercise_params(..) to get a exercise parameters.)")

        self.x, self.angle = params
        self.pid = pid
        # # Values passed to `show_value(..)` inside `pid.control(..)` are collected to `_collected_values`, if `collect` is true.
        # self._collect = collect
        # self._collected_values: Dict[str, Tuple[float, bool]] = {}

        self._gravity = math.sin(math.radians(self.angle)) * _GRAVITY 
        rect = pygame.Surface((30, 23))
        rect.set_colorkey("black")
        rect.fill("red")
        self._rect = pygame.transform.rotate(rect, -self.angle)

    def tick(self, delta: float):
        # # Start collecting values to `_collected_values`
        # if self._collect:
        #     self._collected_values.clear()
        #     _collection_target.set(self._collected_values)
        # Run PID controller `control` method
        try:
            control_return = self.pid.control(delta, self.x)
        except Exception as err:
            raise exerciser.CodeRunError("Error running control method") from err
        # finally:
        #     # Stop collecting values to `_collected_values`
        #     if self._collect:
        #         _collection_target.set(None)

        if not isinstance(control_return, numbers.Real):
            # TODO: Show actual returned value?
            raise exerciser.ValidationError("Error simulating solution: Control method did not return a number")

        self.F = min(max(control_return, -100), 100)       

        self.t += delta
        # TODO: Is silently ignoring NaN bad?
        self.vx += ((0 if math.isnan(self.F) else self.F) + self._gravity) * delta
        self.x += self.vx * delta

    def draw(self, screen: pygame.Surface):
        exerciser.show_simulation_value("α", f"{self.angle:.1f}°")
        exerciser.show_simulation_value("t", f"{self.t:.2f}")
        exerciser.show_simulation_value("x", f"{self.x:.2f}")
        exerciser.show_simulation_value("vx", f"{self.vx:.2f}")
        exerciser.show_simulation_value("F", f"{self.F:.2f}")

        # for k, (v, _) in self._collected_values.items():
        #     if isinstance(v, float):
        #         exerciser.pygame.show_value(f"{k} = {v:.2f}")
        #     else:
        #         exerciser.pygame.show_value(f"{k} = {v}")

        up_axis = pygame.Vector2(0, -1)
        up_axis.rotate_ip(self.angle)
        right_axis = pygame.Vector2(-up_axis.y, up_axis.x)
        center = pygame.Vector2(screen.get_width() / 2, screen.get_height() / 2)

        exerciser.pygame.draw_dashed_line(screen, "gray", center + screen.get_height() * up_axis, center - screen.get_height() * up_axis, pattern=(10, 8))

        mass_center = center + self.x * right_axis
        rect_bounds = self._rect.get_rect()
        rect_bounds.center = (int(mass_center.x), int(mass_center.y))
        screen.blit(self._rect, rect_bounds)
        floor_center = center - 11 * up_axis
        pygame.draw.line(screen, "orange", floor_center + screen.get_width() * right_axis, floor_center - screen.get_width() * right_axis, width=2)

        # exerciser.pygame.draw_arrow(screen, "purple", mass_center, self._gravity * right_axis, 1)
        exerciser.pygame.draw_arrow(screen, "purple", mass_center, (0, _GRAVITY), 1)
        exerciser.pygame.draw_arrow(screen, "green3", mass_center, self.vx * right_axis, 2)
        if not math.isnan(self.F):
            exerciser.pygame.draw_arrow(screen, "blue", mass_center, self.F * right_axis, 2)

# TODO: Some kind of method to simulate and find stabilization time?

# def show_value(label: str, value: Any, plot = False):
#     values = _collection_target.get()
#     if values is not None:
#         if plot and not isinstance(value, numbers.Real):
#             raise ValueError(f"Cannot plot non-numeric value {value}")
#         values[label] = (value, plot)

def plot_and_visualize(pid: PID, params: ExerciseParams, max_time = 30, interactive = False):
    """
    Convenience function to plot and visualize the behavior of the given PID controller with one function call.

    Equivalent to calling `plot` and `visualize`.
    """
    plot(pid, params, max_time, interactive)
    visualize(pid, params)

# Note: plot and visualize make a deep copy of the PID controller to avoid mutating the original value.
# TODO: Is an automatic deep copy an antipatern?
# TODO: Is there a meaningful risk that a student will create a PID class that breaks with deepcopy?

def plot(pid: PID, params: ExerciseParams, max_time = 30, interactive = False):
    """
    Simulate and plot the behavior of the given PID controller.

    Shows a matplotlib plot with the values of some relevant variables over time (block position `x`, velocity `vx` and PID controller applied force `F`).

    `interactive` enables interactive mode. In interactive mode the same figure will be redrawn with new data instead of creating a new figure.
    This is meant to be used with `ipywidgets.interact`.
    """

    if interactive:
        # TODO: Clearing resets zoom (only relevant with widget backend). Is there a way to update data on existing lines without lots of extra code?
        with plt.ioff():
            fig = plt.figure(f"{PIDSimulation.name} - Interactive", clear=True)
        fig = fig # type: ignore
    else:
        # Creating a new plot every time will eventually hurt performance when using the widget backend.
        # Closing the previous plot prevents drawing multiple interactive plots with this function (only relevant with widget backend).
        # TODO: Is there a way to avoid performance issues while still allowing more than one plot to be interactive at the same time?
        plt.close(PIDSimulation.name)
        fig = plt.figure(PIDSimulation.name)
    ax = fig.gca()

    hist_t = np.arange(0, max_time, exerciser.DELTA)
    hist_x, hist_vx, hist_F = [], [], []
    # hist_extra = {}
    sim = PIDSimulation(copy.deepcopy(pid), params)
    for _ in hist_t:
        sim.tick(DELTA)
        # initial_len = len(hist_x)
        hist_x.append(sim.x)
        hist_vx.append(sim.vx)
        hist_F.append(sim.F)
        # for k, (v, plot) in presimulate_exercise._collected_values.items():
        #     if plot:
        #         data = hist_extra.setdefault(k, [])
        #         if len(data) < initial_len:
        #             data += [math.nan] * initial_len
        #         data.append(v)
    ax.axhline(y=0.0, lw=0.8, ls='--', color="darkgrey")
    ax.plot(hist_t[:len(hist_x)], hist_x, label="x", color="red")
    ax.plot(hist_t[:len(hist_vx)], hist_vx, label="vx", color="green")
    ax.plot(hist_t[:len(hist_F)], hist_F, label="F", color="blue")
    # ax.set_prop_cycle(color=["c", "m", "y", "orange", "brown"])
    # for k, v in hist_extra.items():
    #     ax.plot(hist_t[:len(v)], v, label=k)
    ax.legend()

    if interactive:
        exerciser.matplotlib.show_interactive(fig)
    else:
        plt.show()

def visualize(pid: PID, params: ExerciseParams):
    """
    Simulate and visualize the behavior of the given PID controller.

    Shows an interactive view of the simulation in a Pygame window.
    """

    exerciser.run(PIDSimulation(copy.deepcopy(pid), params))

if __name__ == '__main__':
    raise RuntimeError("Do not run this file directly. Instead call the simulate(..) function from this module in your solution.")
