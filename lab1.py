import copy
import math
import numbers
import random
from typing import NamedTuple, Protocol, Optional
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import numpy as np
import exerciser
import pygame # Note: Pygame must be imported after exerciser to avoid the welcome message.

from exerciser import show_value, DELTA, TPS # Re-export

# NB: DO NOT EDIT THIS FILE!

class PID(Protocol):
    def control(self, delta: float, x: float) -> float:
        ...

class ExerciseParams(NamedTuple):
    x: float # Starting position (cm)
    angle: float # Surface angle (degrees)
    noise: float = 0.0 # Sensor noise (normal distribution standard deviation, cm)
    seed: int = 0 # RNG seed (only used with sensor noise)

def get_exercise_params(exercise: int) -> ExerciseParams:
    """
    Get exercise parameters by exercise number (in the range 1..3).
    Note that the parameters of exercise 3 are random.
    """

    if exercise == 1:
        return ExerciseParams(100, 0)
    elif exercise == 2:
        return ExerciseParams(100, 30)
    elif exercise == 3:
        return ExerciseParams(random.uniform(-200, 200), random.uniform(-60, 60))
    elif exercise == 4:
        return ExerciseParams(random.uniform(-200, 200), random.uniform(-60, 60), noise=1.0, seed=random.getrandbits(64))
    else:
        raise exerciser.ValidationError(f"Unknown exercise number: {exercise}")

_GRAVITY = 50 # Effective gravitational acceleration (cm/s^2)

# # Thread-local variable for storing reference to dictionary where user-shown values are stored.
# _collection_target: ContextVar[Optional[Dict]] = ContextVar('collected_values', default=None)

class PIDSimulation(exerciser.Simulation):
    name = "Lab 1 - PID"

    # TODO: Currently distance units are pixels. Should we use more natural distance units such as meters with some kind of scaling constant?
    t = 0.0
    x: float
    vx = 0.0
    F = math.nan

    def __init__(self, pid: PID, params: ExerciseParams):
        if not isinstance(params, ExerciseParams):
            raise exerciser.ValidationError(f"Expected exercise parameters, got {params}. (Call get_exercise_params(..) to get a exercise parameters.)")

        self.x, self.angle, self.noise, _ = params
        self.measured_x = self.x
        self.pid = pid
        # # Values passed to `show_value(..)` inside `pid.control(..)` are collected to `_collected_values`, if `collect` is true.
        # self._collect = collect
        # self._collected_values: Dict[str, Tuple[float, bool]] = {}

        self._random = random.Random(params.seed)
        self._gravity = math.sin(math.radians(self.angle)) * _GRAVITY
        rect = pygame.Surface((30, 23))
        rect.set_colorkey("black")
        rect.fill("red")
        self._rect = pygame.transform.rotate(rect, -self.angle)

    def tick(self, delta: float):
        try:
            control_return = self.pid.control(delta, self.measured_x)
        except Exception as err:
            raise exerciser.CodeRunError("Error running control method") from err

        if not isinstance(control_return, numbers.Real):
            # TODO: Show actual returned value?
            raise exerciser.ValidationError("Error simulating solution: Control method did not return a number")

        self.F = min(max(control_return, -100), 100)       

        # TODO: Add friction?

        self.t += delta
        # TODO: Is silently ignoring NaN bad?
        self.vx += ((0 if math.isnan(self.F) else self.F) + self._gravity) * delta
        self.x += self.vx * delta
        self.measured_x = self.x
        if self.noise != 0.0:
            self.measured_x += self._random.gauss(0.0, self.noise)

    def draw(self, screen: pygame.Surface):
        # Scale 1 pixel = 1 cm

        exerciser.show_simulation_value("α", f"{self.angle:.1f}°")
        exerciser.show_simulation_value("t", f"{self.t:.2f} s")
        exerciser.show_simulation_value("x", f"{self.x:.2f} cm")
        exerciser.show_simulation_value("vx", f"{self.vx:.2f} cm/s")
        exerciser.show_simulation_value("F", f"{self.F:.2f} cN")

        up_axis = pygame.Vector2(0, -1)
        up_axis.rotate_ip(self.angle)
        right_axis = pygame.Vector2(-up_axis.y, up_axis.x)
        center = pygame.Vector2(screen.get_width() / 2, screen.get_height() / 2)

        exerciser.pygame.draw_dashed_line(screen, "gray", center + screen.get_height() * up_axis, center - screen.get_height() * up_axis, pattern=(10, 8))

        mass_center = center + self.x * right_axis
        rect_bounds = self._rect.get_rect()
        rect_bounds.center = (int(mass_center.x), int(mass_center.y))
        screen.blit(self._rect, rect_bounds)
        floor_center = center - 11 * up_axis
        pygame.draw.line(screen, "orange", floor_center + screen.get_width() * right_axis, floor_center - screen.get_width() * right_axis, width=2)

        # exerciser.pygame.draw_arrow(screen, "purple", mass_center, self._gravity * right_axis, 1)
        exerciser.pygame.draw_arrow(screen, "purple", mass_center, (0, _GRAVITY), 1)
        exerciser.pygame.draw_arrow(screen, "green3", mass_center, self.vx * right_axis, 2)
        if not math.isnan(self.F):
            exerciser.pygame.draw_arrow(screen, "blue", mass_center, self.F * right_axis, 2)

# TODO: Some kind of method to simulate and find stabilization time?

def plot_and_visualize(pid: PID, params: ExerciseParams, max_time = 30, figure: Optional[Figure] = None):
    """
    Convenience function to plot and visualize the behavior of the given PID controller with one function call.

    Equivalent to calling `plot` and `visualize`.
    """
    plot(pid, params, max_time, figure)
    visualize(pid, params)

# Note: plot and visualize make a deep copy of the PID controller to avoid mutating the original value.
# TODO: Is an automatic deep copy an antipatern?
# TODO: Is there a meaningful risk that a student will create a PID class that breaks with deepcopy?

def plot(pid: PID, params: ExerciseParams, max_time = 30, figure: Optional[Figure] = None):
    """
    Simulate and plot the behavior of the given PID controller.

    Shows a matplotlib plot with the values of some relevant variables over time (block position `x`, velocity `vx` and PID controller applied force `F`).

    `interactive` enables interactive mode. In interactive mode the same figure will be redrawn with new data instead of creating a new figure.
    This is meant to be used with `ipywidgets.interact`.
    """

    # `widget` backend in general is full of hidden assumptions that need to be upheld for it to behave as expected.
    # See TODO notes below for some specific issues.
    # TODO: Track https://github.com/matplotlib/ipympl/issues/171, https://github.com/matplotlib/ipympl/issues/60 and https://github.com/matplotlib/ipympl/issues/4.
    # Update workarounds if/when these issues get resolved.

    if figure is not None:
        # TODO: Clearing resets zoom (only relevant with widget backend). Is there a way to update data on existing lines without lots of extra code?
        fig = figure
        fig.clear()
    else:
        # Creating a new plot every time will eventually hurt performance when using the widget backend.
        # Closing the previous plot prevents drawing multiple interactive plots with this function (only relevant with widget backend).
        # TODO: Is there a way to avoid performance issues while still allowing more than one plot to be interactive at the same time?
        plt.close(PIDSimulation.name)
        fig = plt.figure(PIDSimulation.name)
    ax = fig.gca()

    hist_t = np.arange(0, max_time, exerciser.DELTA)
    hist_x, hist_m_x, hist_vx, hist_F = [], [], [], []
    sim = PIDSimulation(copy.deepcopy(pid), params)
    for _ in hist_t:
        sim.tick(DELTA)
        hist_x.append(sim.x)
        hist_m_x.append(sim.measured_x)
        hist_vx.append(sim.vx)
        hist_F.append(sim.F)
    ax.axhline(y=0.0, lw=0.8, ls='--', color="darkgrey")
    ax.plot(hist_t[:len(hist_F)], hist_F, label="F (cN)", color="blue")
    if params.noise != 0.0:
        ax.plot(hist_t[:len(hist_m_x)], hist_m_x, label="", color="orange", ls='', marker='o', ms=1)
    ax.plot(hist_t[:len(hist_x)], hist_x, label="x (cm)", color="red")
    ax.plot(hist_t[:len(hist_vx)], hist_vx, label="vx (cm/s)", color="green")
    ax.set_xlabel('time (s)')
    ax.legend()

def visualize(pid: PID, params: ExerciseParams):
    """
    Simulate and visualize the behavior of the given PID controller.

    Shows an interactive view of the simulation in a Pygame window.
    """

    exerciser.run(PIDSimulation(copy.deepcopy(pid), params))

if __name__ == '__main__':
    raise RuntimeError("Do not run this file directly. Instead call the simulate(..) function from this module in your solution.")
