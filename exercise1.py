from dataclasses import dataclass
import math
import numbers
from typing import Callable, Optional, Protocol
from matplotlib.lines import Line2D
import matplotlib.pyplot
import exerciser
import pygame
import numpy as np

# NB: Do not edit this file!

class PID(Protocol):
    def control(self, delta: float, x: float) -> float:
        ...

# This allows plotting with matplotlib in more or less real time.
# TODO: Do we want to use this?
# class InteractivePlot:
#     def __init__(self, lines: list[Line2D]):
#         self.lines = lines
#         self.data_x = []
#         self.data_y = [[] for _ in lines]
#
#     def append(self, x: float, y: Iterable[float]):
#         self.data_x.append(x)
#         for i, val in enumerate(y):
#             self.data_y[i].append(val)
#
#     def draw(self):
#         # TODO: Only update on some ticks for performance? This makes the matplotlib window feel laggy.
#         if len(self.data_x) % 6 == 0:
#             for i, line in enumerate(self.lines):
#                 line.set_xdata(self.data_x)
#                 line.set_ydata(self.data_y[i])
#             matplotlib.pyplot.gca().relim()
#             matplotlib.pyplot.gca().autoscale_view()
#             # TODO: This moves the matplotlib window on top of other windows. Can this be fixed?
#             matplotlib.pyplot.pause(0.01)

@dataclass
class BlockExercise:
    name = "Lab 1 - PID"

    t = 0.0
    x = 100.0
    vx = 0.0
    F = math.nan
    pid_controller: PID
    cursor: Optional[Line2D]

    def tick(self, delta: float):
        try:
            control_return = self.pid_controller.control(delta, self.x)
        except Exception:
            raise exerciser.CodeRunError("Error running control method")

        if not isinstance(control_return, numbers.Real):
            # TODO: Show actual returned value?
            raise exerciser.ValidationError("Error simulating solution: Control method did not return a number")

        self.F = np.clip(control_return, -1000, 1000)       

        self.t += delta
        # TODO: Is silently ignoring NaN bad?
        if not math.isnan(self.F):
            self.vx += self.F * delta
        self.x += self.vx * delta

    def draw(self, screen: pygame.Surface):
        if self.cursor is not None:
            self.cursor.set_xdata((self.t, self.t))

        # exerciser.show_value("t", round(self.t, 2))
        exerciser.show_value("x", round(self.x, 2))
        exerciser.show_value("vx", round(self.vx, 2))
        exerciser.show_value("F", round(self.F, 2))

        pygame.draw.line(screen, "gray", (screen.get_width() / 2, 0), (screen.get_width() / 2, screen.get_height()))

        center_pos = (self.x + screen.get_width() / 2, screen.get_height() / 2)
        pygame.draw.rect(screen, "red", ((center_pos[0] - 10, center_pos[1] - 10), (20, 20)))
        exerciser.pygame.draw_arrow(screen, "green3", center_pos, (self.vx, 0), 2)
        if not math.isnan(self.F):
            exerciser.pygame.draw_arrow(screen, "blue", center_pos, (self.F, 0), 2)

def run(create_pid: Callable[[], PID], exercise: int):
    # TODO: It would probably be more student-friendly to directly take in a PIDController,
    #  but then we would have to reuse the presimulated state for the start of the simulation as well,
    #  because otherwise the PID controller would have incorrect initial state.

    matplotlib.pyplot.clf()
    hist_t = np.arange(0, 30, exerciser.DELTA)
    hist_x = []
    hist_vx = []
    hist_F = []
    presimulate_exercise = BlockExercise(create_pid(), None)
    for t in hist_t:
        try:
            presimulate_exercise.tick(exerciser.DELTA)
        except (exerciser.CodeRunError, exerciser.ValidationError):
            # TODO: Better wording?
            matplotlib.pyplot.xlabel(f"Error simulating solution at t = {t:.2f}", color="red", loc='right')
            break
        hist_x.append(presimulate_exercise.x)
        hist_vx.append(presimulate_exercise.vx)
        hist_F.append(presimulate_exercise.F)
    cursor = matplotlib.pyplot.axvline(x=0.0, lw=0.8)
    matplotlib.pyplot.plot(hist_t[:len(hist_x)], hist_x, label="x", color="red")
    matplotlib.pyplot.plot(hist_t[:len(hist_vx)], hist_vx, label="vx", color="green")
    matplotlib.pyplot.plot(hist_t[:len(hist_F)], hist_F, label="F", color="blue")
    matplotlib.pyplot.legend()
    matplotlib.pyplot.show(block=False)

    exerciser.run_pygame(BlockExercise(create_pid(), cursor))

if __name__ == '__main__':
    raise RuntimeError("Do not run this file directly. Instead call the run(..) function from this module in your solution.")
