import copy
import math
import numbers
import random
from typing import NamedTuple, Protocol
import matplotlib.pyplot
import exerciser
import pygame
import numpy as np

from exerciser import show_value, DELTA, TPS # Re-export

# NB: DO NOT EDIT THIS FILE!

class PID(Protocol):
    def control(self, delta: float, x: float) -> float:
        ...

class Params(NamedTuple):
    x: float
    angle: float

def _to_params(exercise: int | Params) -> Params:
    if isinstance(exercise, Params):
        return exercise
    elif exercise == 1:
        return Params(100, 0)
    elif exercise == 2:
        return Params(100, 30)
    elif exercise == 3:
        return Params(random.uniform(-200, 200), random.uniform(-60, 60))
    else:
        raise exerciser.ValidationError(f"Unknown exercise number: {exercise}")

_GRAVITY = 50 # Effective gravitational acceleration: 50 px/s^2

# # Thread-local variable for storing reference to dictionary where user-shown values are stored.
# _collection_target: ContextVar[Optional[Dict]] = ContextVar('collected_values', default=None)

class BlockExercise(exerciser.Exercise):
    name = "Lab 1 - PID"

    # TODO: Currently distance units are pixels. Should we use more natural distance units such as meters with some kind of scaling constant?
    t = 0.0
    x: float
    vx = 0.0
    F = math.nan

    def __init__(self, pid: PID, exercise: int | Params):
        self.x, self.angle = _to_params(exercise)
        self.pid = pid
        # # Values passed to `show_value(..)` inside `pid.control(..)` are collected to `_collected_values`, if `collect` is true.
        # self._collect = collect
        # self._collected_values: Dict[str, Tuple[float, bool]] = {}

        self._gravity = math.sin(math.radians(self.angle)) * _GRAVITY 
        rect = pygame.Surface((30, 23))
        rect.set_colorkey("black")
        rect.fill("red")
        self._rect = pygame.transform.rotate(rect, -self.angle)

    def tick(self, delta: float):
        # # Start collecting values to `_collected_values`
        # if self._collect:
        #     self._collected_values.clear()
        #     _collection_target.set(self._collected_values)
        # Run PID controller `control` method
        try:
            control_return = self.pid.control(delta, self.x)
        except Exception as err:
            raise exerciser.CodeRunError("Error running control method") from err
        # finally:
        #     # Stop collecting values to `_collected_values`
        #     if self._collect:
        #         _collection_target.set(None)

        if not isinstance(control_return, numbers.Real):
            # TODO: Show actual returned value?
            raise exerciser.ValidationError("Error simulating solution: Control method did not return a number")

        self.F = min(max(control_return, -100), 100)       

        self.t += delta
        # TODO: Is silently ignoring NaN bad?
        self.vx += ((0 if math.isnan(self.F) else self.F) + self._gravity) * delta
        self.x += self.vx * delta

    def draw(self, screen: pygame.Surface):
        exerciser.show_exercise_value("α", f"{self.angle:.1f}°")
        exerciser.show_exercise_value("t", f"{self.t:.2f}")
        exerciser.show_exercise_value("x", f"{self.x:.2f}")
        exerciser.show_exercise_value("vx", f"{self.vx:.2f}")
        exerciser.show_exercise_value("F", f"{self.F:.2f}")

        # for k, (v, _) in self._collected_values.items():
        #     if isinstance(v, float):
        #         exerciser.pygame.show_value(f"{k} = {v:.2f}")
        #     else:
        #         exerciser.pygame.show_value(f"{k} = {v}")

        up_axis = pygame.Vector2(0, -1)
        up_axis.rotate_ip(self.angle)
        right_axis = pygame.Vector2(-up_axis.y, up_axis.x)
        center = pygame.Vector2(screen.get_width() / 2, screen.get_height() / 2)

        exerciser.pygame.draw_dashed_line(screen, "gray", center + screen.get_height() * up_axis, center - screen.get_height() * up_axis, pattern=(10, 8))

        mass_center = center + self.x * right_axis
        rect_bounds = self._rect.get_rect()
        rect_bounds.center = (int(mass_center.x), int(mass_center.y))
        screen.blit(self._rect, rect_bounds)
        floor_center = center - 11 * up_axis
        pygame.draw.line(screen, "orange", floor_center + screen.get_width() * right_axis, floor_center - screen.get_width() * right_axis, width=2)

        # exerciser.pygame.draw_arrow(screen, "purple", mass_center, self._gravity * right_axis, 1)
        exerciser.pygame.draw_arrow(screen, "purple", mass_center, (0, _GRAVITY), 1)
        exerciser.pygame.draw_arrow(screen, "green3", mass_center, self.vx * right_axis, 2)
        if not math.isnan(self.F):
            exerciser.pygame.draw_arrow(screen, "blue", mass_center, self.F * right_axis, 2)

# TODO: Some kind of method to simulate and find stabilization time?

# def show_value(label: str, value: Any, plot = False):
#     values = _collection_target.get()
#     if values is not None:
#         if plot and not isinstance(value, numbers.Real):
#             raise ValueError(f"Cannot plot non-numeric value {value}")
#         values[label] = (value, plot)

def visualize(pid: PID, exercise: int | Params):
    """
    Simulate and visualize the behavior of the given PID controller

    Shows a matplotlib plot with the values of some relevant variables over time (block position `x`, velocity `vx` and PID controller applied force `F`).

    Also shows a live simulation of the same setup in a new window.
    """

    # TODO: Is there a meaningful risk that a student will create a PID class that breaks with deepcopy?
    # TODO: The current presimulation approach is convenient, but assumes that the PID controller is deterministic, which is not guaranteed.

    # Convert to params immediately to ensure both simulations get the same random values
    params = _to_params(exercise)

    fig = matplotlib.pyplot.figure(num=BlockExercise.name, clear=True)
    ax = fig.gca()

    hist_t = np.arange(0, 30, exerciser.DELTA)
    hist_x, hist_vx, hist_F = [], [], []
    # hist_extra = {}
    presimulate_exercise = BlockExercise(copy.deepcopy(pid), params)
    for t in hist_t:
        try:
            presimulate_exercise.tick(DELTA)
        except (exerciser.CodeRunError, exerciser.ValidationError):
            ax.set_xlabel(f"Error simulating solution at t = {t:.2f}", color="red", loc='right')
            break
        # initial_len = len(hist_x)
        hist_x.append(presimulate_exercise.x)
        hist_vx.append(presimulate_exercise.vx)
        hist_F.append(presimulate_exercise.F)
        # for k, (v, plot) in presimulate_exercise._collected_values.items():
        #     if plot:
        #         data = hist_extra.setdefault(k, [])
        #         if len(data) < initial_len:
        #             data += [math.nan] * initial_len
        #         data.append(v)
    ax.axhline(y=0.0, lw=0.8, ls='--', color="darkgrey")
    ax.plot(hist_t[:len(hist_x)], hist_x, label="x", color="red")
    ax.plot(hist_t[:len(hist_vx)], hist_vx, label="vx", color="green")
    ax.plot(hist_t[:len(hist_F)], hist_F, label="F", color="blue")
    # ax.set_prop_cycle(color=["c", "m", "y", "orange", "brown"])
    # for k, v in hist_extra.items():
    #     ax.plot(hist_t[:len(v)], v, label=k)
    ax.legend()
    
    matplotlib.pyplot.show(block=False)

    exerciser.run(BlockExercise(pid, params))

if __name__ == '__main__':
    raise RuntimeError("Do not run this file directly. Instead call the simulate(..) function from this module in your solution.")
